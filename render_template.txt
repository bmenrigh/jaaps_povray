#version 3.7;

#include "colors.inc"
#include "metals.inc"
#include "shapesForUse.inc"
#include "parse.inc"


global_settings {
  assumed_gamma 1.0
}

// ----------------------------------------

#declare zoomcam=TEXTZOOMCAM;

#declare camSquareOrtho= camera {
    orthographic    angle
    location  <0.4, 2.0, -6.0>
    direction 1.5*z
    right     x
    up      y
    look_at   <0.0, -0.01,  0.0>
}

#declare camSquareOrthoZoom= camera {
    orthographic    angle
    location  <0.133, 0.666, -2.0>
    direction 1.5*z
    right     x
    up      y
    look_at   <0.0, -0.01,  0.0>
}

#declare cam_4_3_ratio_Perspectiv= camera {
    location  <0.4, 2.0, -6.0>
    direction 1.5*z
    right     x*4/3
    look_at   <0.0, -0.01,  0.0>
}

#if(zoomcam=0)
camera{
    camSquareOrtho              //output file must be square too
}
#end

#if(zoomcam=1)
camera{
    camSquareOrthoZoom              //output file must be square too
}
#end

#declare userbg=TEXTUSERBG;

#if(userbg=0)
	background {Black}
#end

#if(userbg=1)
	background {White}
#end

#if(userbg=2)
sky_sphere {
    pigment {
	        gradient y
		      color_map {
		       		 [0.0 color blue 0.6]
				 [1.0 color rgb 1]
				 }
		}
}
#end

light_source {
  <0, 0, 0>            // light's position (translated below)
  color rgb <1, 1, 1>  // light's color
  translate <-30,30, -30>
}

light_source {
  <0, 0, 0>            // light's position (translated below)
  color rgb <1, 1, 1>  // light's color
  translate <100,150,100>
}

// -------------------------------------------



// -------------------------------------------
// in this section you can configure the script to your desire

#declare shapeIndex=TEXTSHAPE;
//to define the main object's shape use one of the following indieces
    //0: sphere
    //1: tetrahedron
    //2: cube
    //3: octahedron
    //4: rhombic dodecahedron
    //5: dodecahedron
    //6: icosahedron
    //7: rhombic triacontahedron
    //8: Triakis Octahedron
    //9: Deltoidal Icositetrahedron


#declare tasks=array [8][4] {
//a task is done equally on all directions of a regular direction-vector-set
//it is specified by

//1. symindex ( the direction-vector-set (axle-set) by index), the values can be:
	//1: TC (tetrahedron corners)
	//2: CF (cube faces)
	//3: CC (cube corners)
	//4: CE (cube edges)
	//5: DF (dodecahedron faces)
	//6: DC (dodecahedron corners)
	//7: DE (dodecahedron edges)
	//8: CW (Triakis Octahedron)
	//9: DeltIcosi (Deltoidal Icositetrahedron)

//2. dividerValue based on Jaap's Sphere (scope 300 to 0) : depth

//3. the cone-apex (a float value). there are 5 cases:
	//1. under the origin (negative value)
	//2. on the origin (0)
	//3. between the origin and the divider (value between 0 and depth)
	//4. on the divider (cone-apex == depth), planar cut
	//5. above the divider (value higher than depth)

//4. the color of the cut by index

//the colums are symindex, dividerValue, coneapex, colorindex
      TEXT_CUT_0,
      TEXT_CUT_1,
      TEXT_CUT_2,
      TEXT_CUT_3,
      TEXT_CUT_4,
      TEXT_CUT_5,
      TEXT_CUT_6,
      TEXT_CUT_7,
}

//alternative you can paste a parameter string from Jaap's Sphere's (secret) TextField here, this will overwrite the tasks array
#declare paramstring = ""


//the following values may not need to be changed:


//choose the thickness of the gaps
#declare gth=TEXTCUTWIDTH;




//the orientation of the final main-object is defined here, and applied after all subtractions are done
#declare main_orientation=transform{
    rotate x*18.435
    //rotate <-20,20,0 >
    rotate <TEXTROTX,TEXTROTY,TEXTROTZ>
}


//colors initially set to the colors used by Jaap for the divider rows
#declare divider_row_colors=array[8] {color Red, color Green, color Blue, color Yellow,
									  color BlueViolet, color Coral, color MediumTurquoise , color SpringGreen};


//end of the individual configuration
// -------------------------------------------


#macro getShapeMaterial(mtype, mcolor)
    #switch (mtype)
        #case (0) pigment {mcolor}          #break
        #case (1) material{
	  texture{
	      pigment{mcolor}
	          finish{
		        conserve_energy
			diffuse 0.6
			ambient 0
			specular 0.5
			roughness 0.05
			reflection{0 1 fresnel on metallic 0}
			}
	      }
	      interior{ior 1.16}
	  }            #break
	#case (2) texture{ T_Gold_1C } #break
     #end
#end


#macro getShapeMaterialPreset(mtype)
    #switch (mtype)
        #case (0) getShapeMaterial(mtype, White)          #break
        #case (1) getShapeMaterial(mtype, rgb <0.1, 0.1, 0.1>) #break
        #case (2) getShapeMaterial(mtype, White) #break

    #end
#end


#macro getCutMaterial(mtype, mcolor)
    #switch (mtype)
        #case (0) pigment {mcolor}          #break
        #case (1) material{
	  texture{
	      pigment{mcolor}
	          finish{
		        conserve_energy
			diffuse 0.6
			ambient 0
			specular 0.5
			roughness 0.05
			reflection{0 1 fresnel on metallic 1}
			}
	      }
	      interior{ior 1.16}
	  }            #break

        #case (2) material{
	  texture{
	      pigment{mcolor}
	          finish{
		        conserve_energy
			diffuse 0.6
			ambient 0
			specular 0.5
			roughness 0.05
			reflection{0 1 fresnel on metallic 1}
			}
	      }
	      interior{ior 1.16}
	  }            #break

    #end
#end


#declare usermat=TEXTUSERMAT;

#macro getShape(index)
    #switch (index)
        #case (0) object{shSphere getShapeMaterialPreset(usermat)} #break
        #case (1) object{shTet getShapeMaterialPreset(usermat)} #break
        #case (2) object{shCube getShapeMaterialPreset(usermat)} #break
        #case (3) object{shOct getShapeMaterialPreset(usermat)} #break
        #case (4) object{shRhDod getShapeMaterialPreset(usermat)} #break
        #case (5) object{shDod getShapeMaterialPreset(usermat)} #break
        #case (6) object{shIco getShapeMaterialPreset(usermat)} #break
        #case (7) object{shRhTriacon getShapeMaterialPreset(usermat)} #break
        #case (8) object{shCW getShapeMaterialPreset(usermat)} #break
        #case (9) object{shDeltIcosi getShapeMaterialPreset(usermat)} #break
    #end
#end

#declare mainSolid=getShape(shapeIndex)


#if (strlen(paramstring)>0)
    #declare dividerTable=parse(paramstring)
    #declare tasks=array [16][4];
    #local iRow=0;
    #while (iRow<4)
    	#local iDiv=1;
    	#while (iDiv <= 4)
    		#local iCut=iRow*4 + iDiv -1;
    		#declare tasks[iCut][0]=dividerTable[iRow][0];
    		#declare tasks[iCut][1]=dividerTable[iRow][iDiv];
    		#declare tasks[iCut][2]=0;
    		#declare tasks[iCut][3]=iRow;
    		#local iDiv = iDiv + 1;
    	#end
    #local iRow=iRow+1;
    #end
#end


#macro getDirset(dirsetIndex)
    #switch (dirsetIndex)
        #case (1) dirsTC #break
        #case (2) dirsCF #break
        #case (3) dirsCC #break
        #case (4) dirsCE #break
        #case (5) dirsDF #break
        #case (6) dirsDC #break
        #case (7) dirsDE #break
        #case (8) dirsCW #break
        #case (9) dirsDeltIcosi #break
    #end
#end


//used for fitting
#declare globalScale = 1.8;

// This scale value is the ratio of the circumscribed sphere to the inscribed sphere
#declare shapeScale=array[10]{
    1.0000000000, //0: sphere
    0.3333333333, //1: tetrahedron
    0.5773502692, //2: cube
    0.5773502692, //3: octahedron
    0.7071067812, //4: rhombic dodecahedron
    0.7946544723, //5: dodecahedron
    0.7946544723, //6: icosahedron
    0.8506508084, //7: rhombic tricontahedron
    0.6785983445, //8: Triakis Octahedron
    0.8628562095, //9: Deltoidal Icositetrahedron
}


// ------------------------------------------------------





#macro ConeShell (
	coneDirection, //a normalized direction from the direction-set
	normDiv,  //divider value in the scope 1 to 0
	normApx, //same scale as normDiv -----------new---------------
	gth)	  // gap thickness

	//at the divider = depth of cut
	#local Base_Point = coneDirection * normDiv;
	#local Base_Radius = sqrt(1- normDiv*normDiv );

	//cone vertex
	#local Cap_Point = coneDirection * normApx;

	//half opening angle
	#local hoa = atan(Base_Radius/vlength(Base_Point-Cap_Point));

        //offset to gain the gap-thickness
	#local offst = gth / sin(hoa);

	//make cone big enough
	#local scal=100;
	#local coneHeight= Base_Point - Cap_Point ;

	//Base_Point is translated, Cap_Point is kept
	#local Base_Point = coneHeight * scal + Cap_Point;
	#local Base_Radius = Base_Radius * scal;

        #if (normApx > normDiv )
            #local offst = -offst;
            //for translating the main-cone
            #local tr1=coneDirection * (offst * 0.5 );
            //for translating the subtrahend-cone
            #local tr2=coneDirection * (offst *  1.5 );
        #else
            //for translating the main-cone
            #local tr1=coneDirection * (offst * -1.0 );
            //for translating the subtrahend-cone
            #local tr2=coneDirection * (offst *  0.0 );
        #end

	#local Cap_Radius=0;

	//clip cone-cap if it is outside
	#if(normApx <0)
		#local Cap_Radius=tan(hoa)*vlength(Cap_Point);
		#local Cap_Point=<0,0,0>;
	#end
	#if(normApx > normDiv)
		#local Cap_Radius = tan(hoa) * vlength(coneHeight);
		#local Cap_Point = Cap_Point + coneHeight;
	#end

        //cone is plane
	#if(normApx = normDiv)
		cylinder{
			Base_Point + tr1,
			Base_Point + tr2,
			scal
		}
	#else
	    #local retobj=cone{ Base_Point, Base_Radius, Cap_Point, Cap_Radius }
		difference{
	        object{retobj translate tr1}
	        object{retobj translate tr2}
	    }
	#end

#end



#macro subtract(dirsetIndex,dividerValue,coneApex,colIndex)
    #local dirset=getDirset(dirsetIndex)
    #local dirset_size=dimension_size(dirset,1);



	//handle tetrahedron-corners-dirset special (like Jaap did in the Sphere-Applet)
	#local neg=1;
	/*#if(dirsetIndex = 1)
		#if (dividerValue >= 150)
			#local dividerValue = (dividerValue -150) * 2;
		#else
			#local dividerValue = (150 - dividerValue ) * 2;
			#local neg=-1;
		#end
	#end*/

    //divider-value in scope 1 to 0
    #local normDiv= dividerValue/300;
	#local normApx= coneApex    /300;

    #local Count=0;
    #while (Count<dirset_size) //loop through all directions of the direction-set

    	#local dset=dirset[Count]*neg;

	#local subtrahendSolid= ConeShell(dirset[Count]*neg, normDiv, normApx, gth)

        #local subtrahendSolid = object{subtrahendSolid rotate<TEXTROTCX, TEXTROTCY, TEXTROTCZ>}
        #local subtrahendSolid = object{subtrahendSolid translate<TEXTTRANSCX, TEXTTRANSCY, TEXTTRANSCZ>}

        //here the cone shell is subtracted from the mainSolid
        #declare mainSolid=
            difference{
                object{mainSolid}
                object {subtrahendSolid
		        getCutMaterial(usermat, divider_row_colors[colIndex])}
	    };

    #local Count=Count+1;
    #end

#end





#declare Count=0;
#while(Count < dimension_size(tasks,1))
    #if (tasks[Count][1] >= 0 & tasks[Count][1] <= 300)// jump over if it is -1 or invalid
        subtract(tasks[Count][0],tasks[Count][1],tasks[Count][2],tasks[Count][3])
    #end
#declare Count=Count+1;
#end





// -------------------------------------------------------





//show mainSolid
object { mainSolid
    scale ((shapeScale [shapeIndex]) * globalScale)
    transform{  main_orientation}
}
