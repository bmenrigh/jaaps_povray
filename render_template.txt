#version 3.7;

#include "colors.inc"
#include "metals.inc"
#include "shapesForUse.inc"
//#include "parse.inc"


global_settings {
  assumed_gamma 1.0
}

// ----------------------------------------

#declare zoomcam=TEXTZOOMCAM;

#declare camSquareOrtho= camera {
    orthographic    angle
    location  <0.4, 2.0, -6.0>
    direction 1.5*z
    right     x
    up      y
    look_at   <0.0, -0.01,  0.0>
}

#declare camSquareOrthoZoom= camera {
    orthographic    angle
    location  <0.133, 0.666, -2.0>
    direction 1.5*z
    right     x
    up      y
    look_at   <0.0, -0.01,  0.0>
}

#declare cam_4_3_ratio_Perspectiv= camera {
    location  <0.4, 2.0, -6.0>
    direction 1.5*z
    right     x*4/3
    look_at   <0.0, -0.01,  0.0>
}

#if(zoomcam=0)
camera{
    camSquareOrtho              //output file must be square too
}
#end

#if(zoomcam=1)
camera{
    camSquareOrthoZoom              //output file must be square too
}
#end

#declare userbg=TEXTUSERBG;

#if(userbg=0)
	background {Black}
#end

#if(userbg=1)
	background {White}
#end

#if(userbg=2)
sky_sphere {
    pigment {
	        gradient y
		      color_map {
		       		 [0.0 color blue 0.6]
				 [1.0 color rgb 1]
				 }
		}
}
#end

light_source {
  <0, 0, 0>            // light's position (translated below)
  color rgb <1, 1, 1>  // light's color
  translate <-30,30, -30>
}

light_source {
  <0, 0, 0>            // light's position (translated below)
  color rgb <1, 1, 1>  // light's color
  translate <100,150,100>
}


// This is the shape of the solid
#declare shapeIndex=TEXTSHAPE;


// This is the list of cuts to apply
#declare tasks = array [8][4] {
//a task is done equally on all directions of a regular direction-vector-set
//it is specified by

//1. symindex ( the direction-vector-set (axle-set) by index)

//2. dividerValue based on Jaap's Sphere (scope 300 to 0) : depth

//3. the cone-apex (a float value). there are 5 cases:
	//1. under the origin (negative value)
	//2. on the origin (0)
	//3. between the origin and the divider (value between 0 and depth)
	//4. on the divider (cone-apex == depth), planar cut
	//5. above the divider (value higher than depth)

//4. the color of the cut by index

//the colums are symindex, dividerValue, coneapex, colorindex
      TEXT_CUT_0,
      TEXT_CUT_1,
      TEXT_CUT_2,
      TEXT_CUT_3,
      TEXT_CUT_4,
      TEXT_CUT_5,
      TEXT_CUT_6,
      TEXT_CUT_7,
}


//choose the thickness of the gaps
#declare gth=TEXTCUTWIDTH;


//the orientation of the final main-object is defined here, and applied after all subtractions are done
#declare main_orientation=transform{
	 rotate <TEXTROTX,TEXTROTY,TEXTROTZ>
}


//colors initially set to the colors used by Jaap for the divider rows
#declare divider_row_colors=array[21] {
	 color Red,               //0
	 color Green,		  //1
	 color Blue,		  //2
	 color Yellow,		  //3
	 color BlueViolet,	  //4
	 color Coral,		  //5
	 color MediumTurquoise,	  //6
	 color SpringGreen,	  //7
	 color Magenta,		  //8
	 color Maroon,		  //9
	 color YellowGreen, 	  //10
	 color Orange,		  //11
	 color OrangeRed,	  //12
	 color SeaGreen,	  //13
	 color SummerSky,	  //14
	 color NeonBlue,	  //15
	 color White,	  	  //16
	 color Black,	  	  //17
	 color MediumSlateBlue,	  //18
	 color MediumSpringGreen, //19
	 color Scarlet,		  //20
};


//end of the individual configuration
// -------------------------------------------


#macro getShapeMaterial(mtype, mcolor)
    #switch (mtype)
        #case (0) pigment {mcolor}          #break
        #case (1) material{
	  texture{
	      pigment{mcolor}
	          finish{
		        conserve_energy
			diffuse 0.6
			ambient 0
			specular 0.5
			roughness 0.05
			reflection{0 1 fresnel on metallic 0}
			}
	      }
	      interior{ior 1.16}
	  }            #break
	#case (2) texture{ T_Gold_1C } #break
     #end
#end


#macro getShapeMaterialPreset(mtype)
    #switch (mtype)
        #case (0) getShapeMaterial(mtype, White)          #break
        #case (1) getShapeMaterial(mtype, rgb <0.1, 0.1, 0.1>) #break
        #case (2) getShapeMaterial(mtype, White) #break

    #end
#end


#macro getCutMaterial(mtype, mcolor)
    #switch (mtype)
        #case (0) pigment {mcolor}          #break
        #case (1) material{
	  texture{
	      pigment{mcolor}
	          finish{
		        conserve_energy
			diffuse 0.6
			ambient 0
			specular 0.5
			roughness 0.05
			reflection{0 1 fresnel on metallic 1}
			}
	      }
	      interior{ior 1.16}
	  }            #break

        #case (2) material{
	  texture{
	      pigment{mcolor}
	          finish{
		        conserve_energy
			diffuse 0.6
			ambient 0
			specular 0.5
			roughness 0.05
			reflection{0 1 fresnel on metallic 1}
			}
	      }
	      interior{ior 1.16}
	  }            #break

    #end
#end


#declare usermat=TEXTUSERMAT;

#macro getShape(index)
    #switch (index)
        #case (0) object{shSphere getShapeMaterialPreset(usermat)} #break
        #case (1) object{shTet getShapeMaterialPreset(usermat)} #break
        #case (2) object{shCube getShapeMaterialPreset(usermat)} #break
        #case (3) object{shOct getShapeMaterialPreset(usermat)} #break
        #case (4) object{shRhDod getShapeMaterialPreset(usermat)} #break
        #case (5) object{shDod getShapeMaterialPreset(usermat)} #break
        #case (6) object{shIco getShapeMaterialPreset(usermat)} #break
        #case (7) object{shRhTriacon getShapeMaterialPreset(usermat)} #break
        #case (8) object{shCW getShapeMaterialPreset(usermat)} #break
        #case (9) object{shDeltIcosi getShapeMaterialPreset(usermat)} #break
        #case (10) object{shDeltHex getShapeMaterialPreset(usermat)} #break
        #case (11) object{shTriaTet getShapeMaterialPreset(usermat)} #break
        #case (12) object{shTetraHex getShapeMaterialPreset(usermat)} #break
        #case (13) object{shPentIcosiD getShapeMaterialPreset(usermat)} #break
        #case (14) object{shPentIcosiL getShapeMaterialPreset(usermat)} #break
        #case (15) object{shDisdyDodeca getShapeMaterialPreset(usermat)} #break
        #case (16) object{shPentaDodeca getShapeMaterialPreset(usermat)} #break
        #case (17) object{shTriaIcosa getShapeMaterialPreset(usermat)} #break
	#case (18) object{shPentHexeD getShapeMaterialPreset(usermat)} #break
	#case (19) object{shPentHexeL getShapeMaterialPreset(usermat)} #break
	#case (20) object{shDisdyTria getShapeMaterialPreset(usermat)} #break
	#case (21) object{shTriDipyra getShapeMaterialPreset(usermat)} #break
	#case (22) object{shPentDipyra getShapeMaterialPreset(usermat)} #break
	#case (23) object{shHexDipyra getShapeMaterialPreset(usermat)} #break
	#case (24) object{shHepDipyra getShapeMaterialPreset(usermat)} #break
	#case (25) object{shOctDipyra getShapeMaterialPreset(usermat)} #break
	#case (26) object{shTetraTrapezo getShapeMaterialPreset(usermat)} #break
	#case (27) object{shPentTrapezo getShapeMaterialPreset(usermat)} #break
	#case (28) object{shHexTrapezo getShapeMaterialPreset(usermat)} #break
	#case (29) object{shHeptTrapezo getShapeMaterialPreset(usermat)} #break
	#case (30) object{shOctTrapezo getShapeMaterialPreset(usermat)} #break
	#case (31) object{shTrapRhomDod getShapeMaterialPreset(usermat)} #break
	#case (32) object{shPseuDeltIcosi getShapeMaterialPreset(usermat)} #break
	#case (33) object{shTrapRhomTria getShapeMaterialPreset(usermat)} #break
	#case (34) object{shTriPrism getShapeMaterialPreset(usermat)} #break
	#case (35) object{shPentPrism getShapeMaterialPreset(usermat)} #break
	#case (36) object{shHexPrism getShapeMaterialPreset(usermat)} #break
	#case (37) object{shHepPrism getShapeMaterialPreset(usermat)} #break
	#case (38) object{shOctPrism getShapeMaterialPreset(usermat)} #break
	#case (39) object{shTruncCube getShapeMaterialPreset(usermat)} #break
	#case (40) object{shTruncDod getShapeMaterialPreset(usermat)} #break
	#case (41) object{shCubocto getShapeMaterialPreset(usermat)} #break
	#case (42) object{shIcosidod getShapeMaterialPreset(usermat)} #break
	#case (43) object{shTrunctet getShapeMaterialPreset(usermat)} #break
	#case (44) object{shTruncoct getShapeMaterialPreset(usermat)} #break
	#case (45) object{shATrunccube getShapeMaterialPreset(usermat)} #break
	#case (46) object{shRhomCubOct getShapeMaterialPreset(usermat)} #break
	#case (47) object{shTruncCubOct getShapeMaterialPreset(usermat)} #break
	#case (48) object{shSnubcubeD getShapeMaterialPreset(usermat)} #break
	#case (49) object{shSnubcubeL getShapeMaterialPreset(usermat)} #break
	#case (50) object{shTruncIcosa getShapeMaterialPreset(usermat)} #break
	#case (51) object{shATruncDod getShapeMaterialPreset(usermat)} #break
	#case (52) object{shRhombIcosiDod getShapeMaterialPreset(usermat)} #break
	#case (53) object{shTruncIcosiDod getShapeMaterialPreset(usermat)} #break
	#case (54) object{shSnubDodD getShapeMaterialPreset(usermat)} #break
	#case (55) object{shSnubDodL getShapeMaterialPreset(usermat)} #break
	#case (56) object{shTriPrismSq getShapeMaterialPreset(usermat)} #break
	#case (57) object{shPentPrismSq getShapeMaterialPreset(usermat)} #break
	#case (58) object{shHexPrismSq getShapeMaterialPreset(usermat)} #break
	#case (59) object{shHepPrismSq getShapeMaterialPreset(usermat)} #break
	#case (60) object{shOctPrismSq getShapeMaterialPreset(usermat)} #break
	#case (61) object{shSquareAntiPrism getShapeMaterialPreset(usermat)} #break
	#case (62) object{shPentAntiPrism getShapeMaterialPreset(usermat)} #break
	#case (63) object{shHexAntiPrism getShapeMaterialPreset(usermat)} #break
	#case (64) object{shHepAntiPrism getShapeMaterialPreset(usermat)} #break
	#case (65) object{shOctAntiPrism getShapeMaterialPreset(usermat)} #break
    #end
#end

#declare mainSolid=getShape(shapeIndex)


#macro getDirset(dirsetIndex)
    #switch (dirsetIndex)
        #case (1) dirsTC #break
        #case (2) dirsCF #break
        #case (3) dirsCC #break
        #case (4) dirsCE #break
        #case (5) dirsDF #break
        #case (6) dirsDC #break
        #case (7) dirsDE #break
        #case (8) dirsCW #break
        #case (9) dirsDeltIcosi #break
        #case (10) dirsDeltHex #break
        #case (11) dirsTriaTet #break
        #case (12) dirsTetraHex #break
        #case (13) dirsPentIcosiD #break
        #case (14) dirsPentIcosiL #break
        #case (15) dirsDisdyDodeca #break
        #case (16) dirsPentaDodeca #break
        #case (17) dirsTriaIcosa #break
        #case (18) dirsPentHexeD #break
        #case (19) dirsPentHexeL #break
        #case (20) dirsDisdyTria #break
        #case (21) dirsTriDipyra #break
        #case (22) dirsPentDipyra #break
        #case (23) dirsHexDipyra #break
        #case (24) dirsHepDipyra #break
        #case (25) dirsOctDipyra #break
        #case (26) dirsTetraTrapezo #break
        #case (27) dirsPentTrapezo #break
        #case (28) dirsHexTrapezo #break
        #case (29) dirsHeptTrapezo #break
        #case (30) dirsOctTrapezo #break
        #case (31) dirsTrapRhomDod #break
        #case (32) dirsPseuDeltIcosi #break
        #case (33) dirsTrapRhomTria #break
        #case (34) dirsCutsDihe #break
        #case (35) dirsCutsTriPrism #break
        #case (36) dirsCutsSquarePrism #break
        #case (37) dirsCutsPentPrism #break
        #case (38) dirsCutsHexPrism #break
        #case (39) dirsCutsHepPrism #break
        #case (40) dirsCutsOctPrism #break
        #case (41) dirsTF #break
        #case (42) dirsSquareAntiPrism #break
        #case (43) dirsPentAntiPrism #break
        #case (44) dirsHexAntiPrism #break
        #case (45) dirsHepAntiPrism #break
        #case (46) dirsOctAntiPrism #break
    #end
#end


//used for fitting
#declare globalScale = 1.8;

// This scale value is the ratio of the circumscribed sphere to the inscribed sphere
#declare shapeScale = array[66] {
    1.0000000000, //0: sphere
    0.3333333333, //1: tetrahedron
    0.5773502692, //2: cube
    0.5773502692, //3: octahedron
    0.7071067812, //4: rhombic dodecahedron
    0.7946544723, //5: dodecahedron
    0.7946544723, //6: icosahedron
    0.8506508084, //7: rhombic tricontahedron
    0.6785983445, //8: Triakis Octahedron
    0.8628562095, //9: Deltoidal Icositetrahedron
    0.9245941063, //10: Deltoidal Hexecontahedron
    0.5222329679, //11: Triakis Tetrahedron
    0.6708203932, //12: Tetrakis Hexahedron
    0.8503402074, //13: Pentagonal Icositetrahedron (dextro)
    0.8503402074, //14: Pentagonal Icositetrahedron (laveo)
    0.8259425910, //15: Disdyakis Dodecahedron
    0.9149583817, //16: Pentakis Dodecahedron
    0.8385051474, //17: Triakis Icosahedron
    0.9188614921, //18: Pentagonal Hexecontahedron (dextro)
    0.9188614921, //19: Pentagonal Hexecontahedron (laevo)
    0.9049441875, //20: Disdyakis Triacontahedron
    0.3779644730, //21: Triangular Dipyramid
    0.5067318540, //22: Pentagonal Dipyramid
    0.4472135955, //23: Hexagonal Dipyramid
    0.3980324968, //24: Heptagonal Dipyramid
    0.3574067443, //25: Octagonal Dipyramid
    0.5110810845, //26: Tetragonal Trapezohedron
    0.4472135955, //27: Pentagonal Trapezohedron
    0.3933198932, //28: Hexagonal Trapezohedron
    0.3490502193, //29: Heptagonal Trapezohedron
    0.3127099914, //30: Octagonal Trapezohedron
    0.7071067812, //31: Trapezo-rhombic dodecahedron
    0.8628562095, //32: Pseudo-deltoidal icositetrahedron
    0.8506508084, //33: Trapezo-Rhombic Triacontahedron
    0.4472135955, //34: Triangular Prism
    0.6289601696, //35: Pentagonal Prism
    0.6546536707, //36: Hexagonal Prism
    0.6693623193, //37: Heptagonal Prism
    0.6785983445, //38: Octagonal Prism
    0.8068982214, //39: Truncated cube
    0.9226021945, //40: Truncated Dodecahedron
    0.7071067812, //41: Cuboctohedron
    0.8506508084, //42: Icosidodecahedron
    0.5222329679, //43: Truncated Tetrahedron
    0.7745966692, //44: Truncated Octahedron
    0.6785983445, //45: Truncated Cube
    0.8628562095, //46: Rhombicuboctahedron
    0.8259425910, //47: Truncated Cuboctahedron
    0.8503402074, //48: Snubecube (dextro)
    0.8503402074, //49: Snubecube (laevo)
    0.9149583817, //50: Truncated Icosahedron
    0.8385051474, //51: Truncated Dodecahedron
    0.9245941063, //52: Rhombicosidodecahedron
    0.9049441875, //53: Truncated Icosidodecahedron
    0.9188614921, //54: Snub Dodecahedron (dextro)
    0.9188614921, //55: Snub Dodecahedron (laevo)
    0.3779644730, //56: Triangular Prism Square
    0.5067318540, //57: Pentagonal Prism Square
    0.4472135955, //58: Hexagonal Prism Square
    0.3980324968, //59: Heptagonal Prism Square
    0.3574067443, //60: Octagonal Prism Square
    0.5110810845, //61: Square Antiprism
    0.4472135955, //62: Pentagonal Antiprism
    0.3933198932, //63: Hexagonal Antiprism
    0.3490502193, //64: Heptagonal Antiprism
    0.3127099914, //65: Octagonal Antiprism
}


// ------------------------------------------------------





#macro ConeShell (
	coneDirection, //a normalized direction from the direction-set
	normDiv,  //divider value in the scope 1 to 0
	normApx, //same scale as normDiv -----------new---------------
	gth)	  // gap thickness

	//at the divider = depth of cut
	#local Base_Point = coneDirection * normDiv;
	#local Base_Radius = sqrt(1- normDiv*normDiv );

	//cone vertex
	#local Cap_Point = coneDirection * normApx;

	//half opening angle
	#local hoa = atan(Base_Radius/vlength(Base_Point-Cap_Point));

        //offset to gain the gap-thickness
	#local offst = gth / sin(hoa);

	//make cone big enough
	#local scal=100;
	#local coneHeight= Base_Point - Cap_Point ;

	//Base_Point is translated, Cap_Point is kept
	#local Base_Point = coneHeight * scal + Cap_Point;
	#local Base_Radius = Base_Radius * scal;

        #if (normApx > normDiv )
            #local offst = -offst;
            //for translating the main-cone
            #local tr1=coneDirection * (offst * 0.5 );
            //for translating the subtrahend-cone
            #local tr2=coneDirection * (offst *  1.5 );
        #else
            //for translating the main-cone
            #local tr1=coneDirection * (offst * -1.0 );
            //for translating the subtrahend-cone
            #local tr2=coneDirection * (offst *  0.0 );
        #end

	#local Cap_Radius=0;

	//clip cone-cap if it is outside
	#if(normApx <0)
		#local Cap_Radius=tan(hoa)*vlength(Cap_Point);
		#local Cap_Point=<0,0,0>;
	#end
	#if(normApx > normDiv)
		#local Cap_Radius = tan(hoa) * vlength(coneHeight);
		#local Cap_Point = Cap_Point + coneHeight;
	#end

        //cone is plane
	#if(normApx = normDiv)
		cylinder{
			Base_Point + tr1,
			Base_Point + tr2,
			scal
		}
	#else
	    #local retobj=cone{ Base_Point, Base_Radius, Cap_Point, Cap_Radius }
		difference{
	        object{retobj translate tr1}
	        object{retobj translate tr2}
	    }
	#end

#end



#macro subtract(dirsetIndex,dividerValue,coneApex,colIndex)
    #local dirset=getDirset(dirsetIndex)
    #local dirset_size=dimension_size(dirset,1);

	//handle tetrahedron-corners-dirset special (like Jaap did in the Sphere-Applet)
	#local neg=1;
	/*#if(dirsetIndex = 1)
		#if (dividerValue >= 150)
			#local dividerValue = (dividerValue -150) * 2;
		#else
			#local dividerValue = (150 - dividerValue ) * 2;
			#local neg=-1;
		#end
	#end*/

    //divider-value in scope 1 to 0
    #local normDiv= dividerValue/300;
	#local normApx= coneApex    /300;

    #local Count=0;
    #while (Count<dirset_size) //loop through all directions of the direction-set

    	#local dset=dirset[Count]*neg;

	#local subtrahendSolid= ConeShell(dirset[Count]*neg, normDiv, normApx, gth)

        #local subtrahendSolid = object{subtrahendSolid rotate<TEXTROTCX, TEXTROTCY, TEXTROTCZ>}
        #local subtrahendSolid = object{subtrahendSolid translate<TEXTTRANSCX, TEXTTRANSCY, TEXTTRANSCZ>}

        //here the cone shell is subtracted from the mainSolid
        #declare mainSolid=
            difference{
                object{mainSolid}
                object {subtrahendSolid
		        getCutMaterial(usermat, divider_row_colors[colIndex])}
	    };

    #local Count=Count+1;
    #end

#end



// This routine iterates through the tasks and does the cutting
#declare Count=0;
#while(Count < dimension_size(tasks,1))
    #if (tasks[Count][1] >= 0 & tasks[Count][1] <= 300)// jump over if it is -1 or invalid
        subtract(tasks[Count][0],tasks[Count][1],tasks[Count][2],tasks[Count][3])
    #end
#declare Count=Count+1;
#end

//show mainSolid
object { mainSolid
    scale ((shapeScale [shapeIndex]) * globalScale)
    transform{  main_orientation}
}
